# 装饰器
装饰器背后的主要动机源自于Python面向对象编程。装饰器是在函数调用之上的修饰。这些修饰仅是当声明一个函数或者方法的时候，才会被应用的额外调用。
***装饰器本质上是一个Python函数， 它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试（增加计时逻辑检测性能）、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。***
装饰器的语法以@开头，接下来是装饰器函数的名字和可选参数。紧跟着装饰器生命的是被修饰的函数和装饰函数的可选参数。装饰器看起来会是这样的：
```
@decorator(dec_opt_args):
def func(func_opt_args):
	pass
```
装饰器可以堆叠
```
@deco2
@deco1
def func(arg1, arg2, ...):
	pass
```
等价于
```
def func(arg1, arg2, ...):
	pass
func = deco2(deco1(func))

```
类方法和实例方法
`@classmethod, @staticmethod`
1. 在Python中，方法分为三类实例方法、类方法、静态方法；
2. 逻辑上讲：类方法是只能由类名调用；静态方法可以由类名或对象名进行调用；
3. Python的实例可以调用实例方法、类方法、静态方法。